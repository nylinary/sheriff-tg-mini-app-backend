<!-- Exchange types filtering (works only on exchange page; safe on other pages) -->
<script>
(function () {
  const EXCHANGE_TYPE_STORAGE_KEY = "__sheriff_selected_exchange_type_v1";

  // Prevent early ReferenceError: exchange-type code calls applyReceiveTypeRules()
  // before receive-type section is initialized.
  let applyReceiveTypeRules = function () {};

  const CITY_EXCHANGE_TYPES = {
    "Москва": ["USDT/RUB", "RUB/USDT"],
    "Санкт-Петербург": ["USDT/RUB", "RUB/USDT"],
    "Тверь": ["USDT/RUB", "RUB/USDT"],

    "Кипр": ["USDT/EUR", "EUR/USDT"],
    "Вена": ["USDT/EUR", "EUR/USDT"],
    "Прага": ["USDT/EUR", "EUR/USDT"],
    "Будапешт": ["USDT/EUR", "EUR/USDT"],
    "Братислава": ["USDT/EUR", "EUR/USDT"],

    "Ташкент": ["USDT/USD", "USD/USDT"],
    "Израиль": ["USDT/USD", "USD/USDT"],
    "Нью-Йорк": ["USDT/USD", "USD/USDT"],
    "Лас-Вегас": ["USDT/USD", "USD/USDT"],
    "Лос-Анджелес": ["USDT/USD", "USD/USDT"],
    "Маями": ["USDT/USD", "USD/USDT"],

    "Тбилиси": ["USDT/USD", "USD/USDT", "USDT/EUR", "EUR/USDT"],

    "Дубай": ["USDT/AED", "AED/USDT"],
  };

  // Default placeholder texts (set to exactly what you show in UI)
  const DEFAULT_EXCHANGE_TYPE_LABEL = "Выберите тип сделки";
  const DEFAULT_RECEIVE_TYPE_LABEL = "Выберите тип получения";

  function normalizeLabel(s) {
    return String(s || "")
      .replace(/\s+/g, " ")
      .trim()
      .replace(/\s*\\\s*/g, "/")
      .replace(/\s*\/\s*/g, "/");
  }

  function getSelectedExchangeType() {
    return localStorage.getItem(EXCHANGE_TYPE_STORAGE_KEY) || "";
  }

  function setSelectedExchangeType(label) {
    const normalized = normalizeLabel(label);
    if (!normalized) {
      localStorage.removeItem(EXCHANGE_TYPE_STORAGE_KEY);
      return;
    }
    localStorage.setItem(EXCHANGE_TYPE_STORAGE_KEY, normalized);
    applyReceiveTypeRules();
  }

  function setExchangeTypeDropdownLabel(label) {
    const el = document.getElementById("selected-echange-type-label");
    if (!el) return;
    // Delay to avoid Webflow overriding label during dropdown close.
    setTimeout(() => {
      el.textContent = label || "";
    }, 0);
  }

  function closeExchangeTypeDropdown() {
    const list = document.getElementById("dd-exchange-types-list");
    const dropdownRoot = list?.closest(".w-dropdown");
    if (!dropdownRoot) return;

    const toggle = dropdownRoot.querySelector(".w-dropdown-toggle");
    const ddList = dropdownRoot.querySelector(".w-dropdown-list");

    dropdownRoot.classList.remove("w--open");
    toggle?.classList.remove("w--open");
    ddList?.classList.remove("w--open");
    toggle?.setAttribute("aria-expanded", "false");
    if (ddList && ddList.style) ddList.style.display = "";
  }

  function resetExchangeTypeToDefault() {
    localStorage.removeItem(EXCHANGE_TYPE_STORAGE_KEY);
    setExchangeTypeDropdownLabel(DEFAULT_EXCHANGE_TYPE_LABEL);
    // exchange type affects receive-type availability
    applyReceiveTypeRules();
  }

  function resetReceiveTypeToDefault() {
    localStorage.removeItem("__sheriff_selected_receive_type_v1");
    const el = document.getElementById("receive-type-dd-label");
    if (el) {
      setTimeout(() => {
        el.textContent = DEFAULT_RECEIVE_TYPE_LABEL;
      }, 0);
    }
  }

  function applyExchangeTypesForCity(cityName) {
    const ddList = document.getElementById("dd-exchange-types-list");
    if (!ddList) return; // not on this page

    const allowed = (CITY_EXCHANGE_TYPES[String(cityName || "").trim()] || []).map(normalizeLabel);

    // Webflow dropdown options are usually .w-dropdown-link
    const wfOptions = ddList.querySelectorAll(".w-dropdown-link");
    const nodes = wfOptions.length ? wfOptions : ddList.querySelectorAll("a, div, li");

    nodes.forEach((node) => {
      if (!(node instanceof HTMLElement)) return;
      const text = normalizeLabel(node.textContent);
      if (!text) return;
      node.style.display = allowed.includes(text) ? "" : "none";
    });

    // If selected exchange type is not allowed for this city -> reset to placeholder
    const currentRaw = getSelectedExchangeType();
    const current = normalizeLabel(currentRaw);
    if (current && !allowed.includes(current)) {
      resetExchangeTypeToDefault();
    } else if (current) {
      // Ensure label stays in sync (fixes occasional empty label)
      setExchangeTypeDropdownLabel(current);
    } else {
      // no selection yet
      setExchangeTypeDropdownLabel(DEFAULT_EXCHANGE_TYPE_LABEL);
    }
  }

  function bindExchangeTypeDropdownClicks() {
    const ddList = document.getElementById("dd-exchange-types-list");
    if (!ddList) return;

    // Use bubble phase so Webflow can process the click first.
    ddList.addEventListener("click", (e) => {
      const target = e.target;
      if (!(target instanceof Element)) return;

      const option = target.closest(".w-dropdown-link");
      if (!(option instanceof HTMLElement)) return;
      if (option.style.display === "none") return;

      const label = normalizeLabel(option.textContent);
      if (!label) return;

      setSelectedExchangeType(label);
      setExchangeTypeDropdownLabel(label);

      // Close after Webflow finishes its own handlers
      setTimeout(() => closeExchangeTypeDropdown(), 0);
    });
  }

  // Hook into the existing city dropdown items from this file (.dd-item)
  document.addEventListener("click", (e) => {
    const item = e.target.closest(".dd-item");
    if (!item) return;
    const cityName = item.getAttribute("data-city-name") || item.textContent.trim();
    if (cityName) applyExchangeTypesForCity(cityName);
  });

  function _firstVisibleOptionText(listId) {
    const list = document.getElementById(listId);
    if (!list) return "";
    const wfOptions = list.querySelectorAll(".w-dropdown-link");
    const nodes = wfOptions.length ? wfOptions : list.querySelectorAll("a, div, li");
    for (const node of nodes) {
      if (!(node instanceof HTMLElement)) continue;
      if (node.style.display === "none") continue;
      const text = normalizeLabel(node.textContent);
      if (text) return text;
    }
    return "";
  }

  document.addEventListener("DOMContentLoaded", () => {
    bindExchangeTypeDropdownClicks();

    const first = document.querySelector(".dd-item[data-city-name]");
    if (first) {
      const cityName = first.getAttribute("data-city-name") || first.textContent.trim();
      if (cityName) applyExchangeTypesForCity(cityName);
    }

    const saved = normalizeLabel(getSelectedExchangeType());
    if (saved) {
      setExchangeTypeDropdownLabel(saved);
    } else {
      setExchangeTypeDropdownLabel(DEFAULT_EXCHANGE_TYPE_LABEL);
    }

    const RECEIVE_TYPE_STORAGE_KEY = "__sheriff_selected_receive_type_v1";

    // Label + list ids (per Webflow)
    const RECEIVE_LABEL_ID = "receive-type-dd-label";
    const RECEIVE_LIST_ID = "receive-type-dd-list";

    // Text matchers (must match *visible text* of your dropdown items)
    const RECEIVE_OFFICE_TEXT = "В офисе \\ с менеджером";
    const RECEIVE_CARD_TEXT = "На карту (Только выплата фиата!)";

    function isOfficeOption(label) {
      return normalizeLabel(label) === normalizeLabel(RECEIVE_OFFICE_TEXT);
    }

    function isCardOption(label) {
      return normalizeLabel(label) === normalizeLabel(RECEIVE_CARD_TEXT);
    }

    function getSelectedReceiveType() {
      return localStorage.getItem(RECEIVE_TYPE_STORAGE_KEY) || "";
    }

    function setSelectedReceiveType(label) {
      if (!label) {
        localStorage.removeItem(RECEIVE_TYPE_STORAGE_KEY);
        return;
      }
      localStorage.setItem(RECEIVE_TYPE_STORAGE_KEY, String(label));
    }

    function setReceiveTypeDropdownLabel(label) {
      const el = document.getElementById(RECEIVE_LABEL_ID);
      if (!el) return;
      setTimeout(() => {
        el.textContent = label || "";
      }, 0);
    }

    function closeReceiveTypeDropdown() {
      const list = document.getElementById(RECEIVE_LIST_ID);
      const dropdownRoot = list?.closest(".w-dropdown");
      const toggle = dropdownRoot?.querySelector(".w-dropdown-toggle");
      if (toggle instanceof HTMLElement) toggle.click();
    }

    // Determine whether the selected exchange type means "buying crypto".
    // Rule: fiat/USDT (e.g. RUB/USDT, USD/USDT, EUR/USDT, AED/USDT) => buying crypto.
    function isBuyingCrypto(exchangeTypeLabelRaw) {
      const t = normalizeLabel(exchangeTypeLabelRaw).toUpperCase();
      return /^(RUB|USD|EUR|AED)\/USDT$/.test(t);
    }

    // Define the real implementation now that receive-type helpers exist.
    applyReceiveTypeRules = function () {
      const ddList = document.getElementById(RECEIVE_LIST_ID);
      if (!ddList) return;

      const exchangeType = getSelectedExchangeType();
      const onlyOffice = isBuyingCrypto(exchangeType);

      const wfOptions = ddList.querySelectorAll(".w-dropdown-link");
      const nodes = wfOptions.length ? wfOptions : ddList.querySelectorAll("a, div, li");

      // Helper: check if an option is visible in the UI
      const isOptionVisible = (predicate) => {
        for (const node of nodes) {
          if (!(node instanceof HTMLElement)) continue;
          if (node.style.display === "none") continue;
          const text = normalizeLabel(node.textContent);
          if (!text) continue;
          if (predicate(text)) return true;
        }
        return false;
      };

      // 1) apply visibility
      nodes.forEach((node) => {
        if (!(node instanceof HTMLElement)) return;
        const text = normalizeLabel(node.textContent);
        if (!text) return;

        if (onlyOffice) {
          node.style.display = isOfficeOption(text) ? "" : "none";
        } else {
          if (isOfficeOption(text) || isCardOption(text)) node.style.display = "";
        }
      });

      // 2) ensure current selection is valid; if not - auto switch to a valid one
      const current = normalizeLabel(getSelectedReceiveType());

      const officeAvailable = onlyOffice ? true : isOptionVisible(isOfficeOption);
      const cardAvailable = !onlyOffice && isOptionVisible(isCardOption);

      const isCurrentValid = onlyOffice
        ? isOfficeOption(current)
        : isOfficeOption(current) || isCardOption(current);

      if (!isCurrentValid) {
        if (cardAvailable) {
          setSelectedReceiveType(RECEIVE_CARD_TEXT);
          setReceiveTypeDropdownLabel(RECEIVE_CARD_TEXT);
        } else if (officeAvailable) {
          setSelectedReceiveType(RECEIVE_OFFICE_TEXT);
          setReceiveTypeDropdownLabel(RECEIVE_OFFICE_TEXT);
        } else {
          resetReceiveTypeToDefault();
        }
      }
    };

    function bindReceiveTypeDropdownClicks() {
      const ddList = document.getElementById(RECEIVE_LIST_ID);
      if (!ddList) return;

      ddList.addEventListener("click", (e) => {
        const target = e.target;
        if (!(target instanceof Element)) return;

        const option = target.closest(".w-dropdown-link") || target.closest("a, div, li");
        if (!(option instanceof HTMLElement)) return;

        const label = normalizeLabel(option.textContent);
        if (!label) return;

        // Prevent selecting hidden options
        if (option.style.display === "none") {
          e.preventDefault?.();
          e.stopPropagation?.();
          return;
        }

        setSelectedReceiveType(label);
        setReceiveTypeDropdownLabel(label);
        closeReceiveTypeDropdown();

        e.preventDefault?.();
        e.stopPropagation?.();
      });
    }

    bindReceiveTypeDropdownClicks();

    // Restore persisted receive type label, otherwise show placeholder
    const savedReceive = normalizeLabel(getSelectedReceiveType());
    if (savedReceive) {
      setReceiveTypeDropdownLabel(savedReceive);
    } else {
      setReceiveTypeDropdownLabel(DEFAULT_RECEIVE_TYPE_LABEL);
    }

    // Apply visibility rules immediately (depends on saved exchange type)
    applyReceiveTypeRules();

    // ====== INPUTS: SUM + WALLET ADDRESS ======
    const SUM_STORAGE_KEY = "__sheriff_selected_sum_v1";
    const WALLET_STORAGE_KEY = "__sheriff_selected_wallet_address_v1";

    function parseValidNumber(raw) {
      const s = String(raw || "").trim();
      if (!s) return null;

      // allow comma as decimal separator, remove spaces
      const normalized = s.replace(/\s+/g, "").replace(/,/g, ".");

      // Valid forms: 123, 123.45, .5, 0.5
      if (!/^([0-9]+(\.[0-9]+)?|\.[0-9]+)$/.test(normalized)) return null;

      const n = Number(normalized);
      if (!Number.isFinite(n)) return null;
      return n;
    }

    function restoreInputValues() {
      const sumEl = document.getElementById("sum-input");
      const walletEl = document.getElementById("wallet-address-input");

      if (sumEl instanceof HTMLInputElement) {
        const savedSum = localStorage.getItem(SUM_STORAGE_KEY);
        if (savedSum != null && savedSum !== "") sumEl.value = savedSum;
      }

      if (walletEl instanceof HTMLInputElement) {
        const savedWallet = localStorage.getItem(WALLET_STORAGE_KEY);
        if (savedWallet != null) walletEl.value = savedWallet;
      }
    }

    function bindInputPersistence() {
      const sumEl = document.getElementById("sum-input");
      const walletEl = document.getElementById("wallet-address-input");

      if (sumEl instanceof HTMLInputElement) {
        // Restrict typing to digits + one decimal separator (.,)
        sumEl.setAttribute("inputmode", "decimal");
        sumEl.setAttribute("autocomplete", "off");

        const sanitizeSum = (raw) => {
          let s = String(raw ?? "");
          // keep only digits and separators
          s = s.replace(/[^0-9.,]/g, "");
          // if multiple separators - keep the first one
          const firstSepIdx = s.search(/[.,]/);
          if (firstSepIdx !== -1) {
            const before = s.slice(0, firstSepIdx + 1);
            const after = s.slice(firstSepIdx + 1).replace(/[.,]/g, "");
            s = before + after;
          }
          // normalize leading separator: ".5" or ",5" allowed
          return s;
        };

        const setSumValidState = (state /* 'valid' | 'invalid' | 'neutral' */) => {
          if (state === "neutral") {
            sumEl.classList.remove("is-invalid");
            sumEl.removeAttribute("aria-invalid");
            return;
          }
          const isValid = state === "valid";
          sumEl.classList.toggle("is-invalid", !isValid);
          sumEl.setAttribute("aria-invalid", (!isValid).toString());
        };

        sumEl.addEventListener("input", () => {
          const sanitized = sanitizeSum(sumEl.value);
          if (sanitized !== sumEl.value) sumEl.value = sanitized;

          if (sanitized.trim() === "") {
            setSumValidState("neutral");
            localStorage.removeItem(SUM_STORAGE_KEY);
            return;
          }

          const parsed = parseValidNumber(sanitized);
          if (parsed == null) {
            setSumValidState("invalid");
            // do not overwrite saved valid value if current is invalid
            return;
          }

          setSumValidState("valid");
          const normalizedToStore = sanitized.trim().replace(/\s+/g, "").replace(/,/g, ".");
          localStorage.setItem(SUM_STORAGE_KEY, normalizedToStore);
        });

        sumEl.addEventListener("blur", () => {
          const raw = sumEl.value;
          if (raw.trim() === "") {
            setSumValidState("neutral");
            localStorage.removeItem(SUM_STORAGE_KEY);
            return;
          }
          const parsed = parseValidNumber(raw);
          if (parsed == null) setSumValidState("invalid");
        });
      }

      if (walletEl instanceof HTMLInputElement) {
        walletEl.setAttribute("autocomplete", "off");
        walletEl.addEventListener("input", () => {
          localStorage.setItem(WALLET_STORAGE_KEY, walletEl.value ?? "");
        });
        walletEl.addEventListener("blur", () => {
          localStorage.setItem(WALLET_STORAGE_KEY, walletEl.value ?? "");
        });
      }
    }

    restoreInputValues();
    bindInputPersistence();
  });

  // Keep #selected-city in sync with user selection on THIS page.
  // Use capture so we run even if Webflow stops propagation.
  document.addEventListener(
    "click",
    (e) => {
      const item = e.target?.closest?.(".dd-item");
      if (!item) return;
      const cityName = item.getAttribute("data-city-name") || item.textContent.trim();
      const label = document.getElementById("selected-city");
      if (label && cityName) label.textContent = cityName;
    },
    true
  );

  // NOTE: Removed the DOMContentLoaded city-sync fallback that picked the first .dd-item
  // and could overwrite the actual selected city.

  // Extend API
  window.SheriffExchangeTypes = {
    applyExchangeTypesForCity,
    getSelectedExchangeType,
    setSelectedExchangeType,
    applyReceiveTypeRules,
    resetExchangeTypeToDefault,
    resetReceiveTypeToDefault,
  };
})();
</script>

<!-- SUBMIT BUTTON LOGIC - Send data to backend and redirect to /bot-done -->
<script>
(function() {
  // Configuration
  const SUBMIT_BUTTON_ID = "submit-btn";
  const BACKEND_BASE = "https://sheriff-tg-mini-app-backend-dev.up.railway.app";
  const LEAD_ENDPOINT = "/leads";
  const AUTH_ENDPOINT = "/auth/telegram-webapp";
  const AUTH_REFRESH_ENDPOINT = "/auth/refresh";
  const TOKEN_STORAGE_KEY = "__sheriff_tokens_v1";
  const CITY_STORAGE_KEY = "__sheriff_selected_city_v1";

  // Default placeholder texts
  const DEFAULT_EXCHANGE_TYPE_LABEL = "Выберите тип сделки";
  const DEFAULT_RECEIVE_TYPE_LABEL = "Выберите тип получения";

  // ====== ЕДИНАЯ СИСТЕМА УПРАВЛЕНИЯ ТОКЕНАМИ ======
  
  function normalizeLabel(s) {
    return String(s || "")
      .replace(/\s+/g, " ")
      .trim()
      .replace(/\s*\\\s*/g, "/")
      .replace(/\s*\/\s*/g, "/");
  }

  // Токены
  function getStoredTokens() {
    try {
      const tokens = JSON.parse(localStorage.getItem(TOKEN_STORAGE_KEY) || "null");
      return tokens;
    } catch {
      return null;
    }
  }

  function setStoredTokens(tokens) {
    if (!tokens) {
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      return;
    }
    localStorage.setItem(TOKEN_STORAGE_KEY, JSON.stringify({
      ...tokens,
      saved_at: Date.now(),
    }));
  }

  function clearStoredTokens() {
    localStorage.removeItem(TOKEN_STORAGE_KEY);
  }

  function areTokensExpired() {
    const tokens = getStoredTokens();
    if (!tokens || !tokens.saved_at || !tokens.expires_in) return true;
    
    const elapsed = Date.now() - tokens.saved_at;
    // Считаем токен просроченным за 5 минут до реального истечения
    return elapsed > (tokens.expires_in * 1000) - (5 * 60 * 1000);
  }

  function hasValidInitData() {
    const initData = window.Telegram?.WebApp?.initData || "";
    return initData && initData.length > 0;
  }

  async function performTelegramAuth() {
    try {
      // Проверяем, есть ли initData
      if (!hasValidInitData()) {
        console.warn("No Telegram initData available on exchange page");
        return null; // Возвращаем null вместо ошибки
      }

      const payload = {
        initData: window.Telegram.WebApp.initData,
        meta: {
          platform: window.Telegram?.WebApp?.platform || null,
          version: window.Telegram?.WebApp?.version || null,
          color_scheme: window.Telegram?.WebApp?.colorScheme || null,
          page_url: location.href,
          user_agent: navigator.userAgent,
        },
      };

      const response = await fetch(BACKEND_BASE + AUTH_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Auth failed:", response.status, errorText);
        return null; // Возвращаем null вместо ошибки
      }

      const data = await response.json();
      
      if (data?.access_token && data?.refresh_token) {
        setStoredTokens({
          access_token: data.access_token,
          refresh_token: data.refresh_token,
          token_type: data.token_type || "bearer",
          expires_in: data.expires_in || 3600,
        });
        console.log("Auth successful on exchange page, tokens saved");
        return data;
      } else {
        console.warn("Auth response without tokens");
        return data;
      }
    } catch (error) {
      console.error("Telegram auth error on exchange page:", error);
      clearStoredTokens();
      return null; // Возвращаем null вместо ошибки
    }
  }

  async function refreshAccessToken() {
    try {
      console.log("Attempting token refresh...");
      const response = await fetch(BACKEND_BASE + AUTH_REFRESH_ENDPOINT, {
        method: "POST",
        credentials: "include",
      });

      if (!response.ok) {
        if (response.status === 401) {
          console.warn("Refresh token expired");
          clearStoredTokens();
          return null; // Возвращаем null вместо ошибки
        }
        const errorText = await response.text();
        console.error("Refresh failed:", response.status, errorText);
        return null; // Возвращаем null вместо ошибки
      }

      const data = await response.json();
      
      if (data?.access_token && data?.refresh_token) {
        setStoredTokens({
          access_token: data.access_token,
          refresh_token: data.refresh_token,
          token_type: data.token_type || "bearer",
          expires_in: data.expires_in || 3600,
        });
        console.log("Token refresh successful");
        return data;
      } else {
        console.warn("Refresh response without tokens");
        return data;
      }
    } catch (error) {
      console.error("Refresh token error:", error);
      clearStoredTokens();
      return null; // Возвращаем null вместо ошибки
    }
  }

  async function ensureValidTokens() {
    try {
      // 1. Если токенов нет вообще
      const tokens = getStoredTokens();
      if (!tokens) {
        console.log("No tokens found");
        
        // Пробуем сделать авторизацию, только если есть initData
        if (hasValidInitData()) {
          console.log("Has initData, trying auth...");
          return await performTelegramAuth();
        } else {
          console.log("No initData, cannot auth on exchange page");
          return null; // Не можем сделать авторизацию без initData
        }
      }
      
      // 2. Если токены просрочены
      if (areTokensExpired()) {
        console.log("Tokens expired, refreshing...");
        const refreshed = await refreshAccessToken();
        if (!refreshed && hasValidInitData()) {
          console.log("Refresh failed, trying full auth...");
          return await performTelegramAuth();
        }
        return refreshed;
      }
      
      // 3. Токены валидны
      console.log("Tokens are valid");
      return tokens;
    } catch (error) {
      console.error("ensureValidTokens error:", error);
      return null;
    }
  }

  async function apiFetch(path, options = {}) {
    // Пробуем получить валидные токены, но не падаем если не получилось
    let tokens = getStoredTokens();
    
    // Если токенов нет или они просрочены, пробуем обновить
    if (!tokens || areTokensExpired()) {
      tokens = await ensureValidTokens();
    }
    
    const headers = new Headers(options.headers || {});
    
    if (tokens?.access_token) {
      headers.set("Authorization", `Bearer ${tokens.access_token}`);
      console.log("Using token for request");
    } else {
      console.warn("No access token available for request, sending without auth");
    }
    
    let response;
    try {
      response = await fetch(BACKEND_BASE + path, {
        ...options,
        headers,
        credentials: "include",
      });
    } catch (error) {
      console.error("Network error:", error);
      throw error;
    }
    
    // Если получили 401, пробуем обновить токен и повторить
    if (response.status === 401) {
      console.log("Received 401, attempting token refresh...");
      const refreshedTokens = await refreshAccessToken();
      
      if (refreshedTokens?.access_token) {
        const newHeaders = new Headers(options.headers || {});
        newHeaders.set("Authorization", `Bearer ${refreshedTokens.access_token}`);
        
        response = await fetch(BACKEND_BASE + path, {
          ...options,
          headers: newHeaders,
          credentials: "include",
        });
      }
    }
    
    return response;
  }

  // ====== ФОРМА И ВАЛИДАЦИЯ ======

  function isNonEmpty(v) {
    return String(v ?? "").trim().length > 0;
  }

  function getSubmitEl() {
    return document.getElementById(SUBMIT_BUTTON_ID);
  }

  function getSubmitForm() {
    // Prefer specific Webflow form id if present
    const byId = document.getElementById("email-form");
    if (byId instanceof HTMLFormElement) return byId;

    // Prefer nearest form when button is inside a form
    const btn = getSubmitEl();
    const byBtn = btn?.closest?.("form") || null;
    if (byBtn) return byBtn;

    // Fallback: find a form containing our inputs (when button is outside)
    const sumEl = document.getElementById("sum-input");
    const walletEl = document.getElementById("wallet-address-input");
    return (
      (sumEl && sumEl.closest && sumEl.closest("form")) ||
      (walletEl && walletEl.closest && walletEl.closest("form")) ||
      null
    );
  }

  // Get form field values - read directly from DOM labels
  function getSelectedCity() {
    const el = document.getElementById("selected-city");
    return normalizeLabel(el?.textContent || "");
  }

  function getSelectedExchangeType() {
    const el = document.getElementById("selected-echange-type-label");
    return normalizeLabel(el?.textContent || "");
  }

  function getSelectedReceiveType() {
    const el = document.getElementById("receive-type-dd-label");
    return normalizeLabel(el?.textContent || "");
  }

  function getSumValue() {
    const el = document.getElementById("sum-input");
    return el instanceof HTMLInputElement ? el.value : "";
  }

  function getWalletValue() {
    const el = document.getElementById("wallet-address-input");
    return el instanceof HTMLInputElement ? el.value : "";
  }

  // Validation
  function isValidSumValue(raw) {
    if (!isNonEmpty(raw)) return false;
    const normalized = String(raw).trim().replace(/\s+/g, "").replace(/,/g, ".");
    if (!/^([0-9]+(\.[0-9]+)?|\.[0-9]+)$/.test(normalized)) return false;
    const n = Number(normalized);
    return Number.isFinite(n);
  }

  function isFormReadyToSubmit() {
    const okCity = isNonEmpty(getSelectedCity());

    const exType = normalizeLabel(getSelectedExchangeType());
    const okExType = isNonEmpty(exType) && exType !== normalizeLabel(DEFAULT_EXCHANGE_TYPE_LABEL);

    const receiveRaw = normalizeLabel(getSelectedReceiveType());
    const okReceive = isNonEmpty(receiveRaw) && receiveRaw !== normalizeLabel(DEFAULT_RECEIVE_TYPE_LABEL);

    const okSum = isValidSumValue(getSumValue());
    const okWallet = isNonEmpty(getWalletValue());

    return okCity && okExType && okReceive && okSum && okWallet;
  }

  // UI state management
  function setFormSubmitEnabled(enabled) {
    const btn = getSubmitEl();
    const form = getSubmitForm();
    const disabled = !enabled;

    if (btn) {
      btn.setAttribute("aria-disabled", disabled.toString());
      btn.classList.toggle("is-disabled", disabled);

      // If submit element is a native form control, disable it.
      if (btn instanceof HTMLButtonElement || btn instanceof HTMLInputElement) {
        btn.disabled = disabled;
        if (disabled) btn.setAttribute("tabindex", "-1");
        else btn.removeAttribute("tabindex");
      } else {
        // If submit is an <a> (Webflow button), keep it clickable and only style it.
        btn.style.opacity = disabled ? "0.6" : "";
        // Do not change tabindex for anchors; Webflow styles may rely on it.
        btn.removeAttribute("tabindex");
      }
    }

    if (form) {
      const submits = form.querySelectorAll('button[type="submit"], input[type="submit"]');
      submits.forEach((el) => {
        if (el instanceof HTMLButtonElement || el instanceof HTMLInputElement) {
          el.disabled = disabled;
        }
        el.setAttribute("aria-disabled", disabled.toString());
        el.classList.toggle("is-disabled", disabled);
      });
    }
  }

  function recomputeSubmitEnabled() {
    setFormSubmitEnabled(isFormReadyToSubmit());
  }

  // Send data to backend (with auto-refresh)
  async function sendLeadToBackend() {
    const payload = {
      city: normalizeLabel(getSelectedCity()),
      exchange_type: normalizeLabel(getSelectedExchangeType()),
      receive_type: normalizeLabel(getSelectedReceiveType()),
      sum: String(getSumValue() || "").trim(),
      wallet_address: String(getWalletValue() || "").trim(),
      meta: {
        page_url: location.href,
        user_agent: navigator.userAgent,
        tg_platform: window.Telegram?.WebApp?.platform || null,
        tg_version: window.Telegram?.WebApp?.version || null,
      },
    };

    console.log("Sending lead:", payload);

    try {
      const response = await apiFetch(LEAD_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("Backend error:", response.status, errorText);
        return false;
      }

      console.log("Lead sent successfully");
      return true;
    } catch (error) {
      console.error("Failed to send lead:", error);
      return false;
    }
  }

  // ====== ИНИЦИАЛИЗАЦИЯ ======
  
  document.addEventListener("DOMContentLoaded", async () => {
    const btn = getSubmitEl();
    const form = getSubmitForm();

    if (!btn) {
      console.warn("Submit button not found");
      return;
    }

    if (!form) {
      console.warn("Form not found (submit button may be outside). Will handle button click only.");
    }

    // 1. Инициализируем Telegram WebApp если доступен
    if (window.Telegram?.WebApp) {
      window.Telegram.WebApp.ready();
      console.log("Telegram WebApp initialized on exchange page");
    }

    // 2. Проверяем токены в фоновом режиме БЕЗ АЛЕРТОВ
    setTimeout(async () => {
      try {
        const tokens = await ensureValidTokens();
        if (tokens) {
          console.log("Tokens validated on page load");
        } else {
          console.log("No valid tokens available - this is normal for new users");
          // НЕ показываем алерт - пользователь мог прийти с главной страницы
          // где авторизация уже сделана, или он новичок
        }
      } catch (error) {
        console.warn("Token validation on load failed:", error);
        // НЕ показываем алерт - это не критичная ошибка
      }
    }, 1000);

    // 3. Настраиваем UI формы
    setFormSubmitEnabled(false);
    recomputeSubmitEnabled();
    
    // Re-check validation after a short delay (Webflow might initialize elements slowly)
    setTimeout(recomputeSubmitEnabled, 100);
    setTimeout(recomputeSubmitEnabled, 500);

    // Listen for changes in form fields
    document.addEventListener("click", (e) => {
      if (e.target?.closest?.(".dd-item") ||
          e.target?.closest?.("#dd-exchange-types-list") ||
          e.target?.closest?.("#receive-type-dd-list")) {
        setTimeout(recomputeSubmitEnabled, 0);
      }
    });

    const sumEl = document.getElementById("sum-input");
    if (sumEl instanceof HTMLInputElement) {
      sumEl.addEventListener("input", () => setTimeout(recomputeSubmitEnabled, 0));
      sumEl.addEventListener("blur", () => setTimeout(recomputeSubmitEnabled, 0));
    }

    const walletEl = document.getElementById("wallet-address-input");
    if (walletEl instanceof HTMLInputElement) {
      walletEl.addEventListener("input", () => setTimeout(recomputeSubmitEnabled, 0));
      walletEl.addEventListener("blur", () => setTimeout(recomputeSubmitEnabled, 0));
    }

    // 4. Handle form submission
    let isSubmitting = false;

    async function handleSubmit(event) {
      // Prevent default Webflow form submission / link navigation
      event?.preventDefault?.();
      event?.stopPropagation?.();

      // If the submit is an <a>, temporarily remove href to prevent navigation race
      const el = getSubmitEl();
      const originalHref = el?.getAttribute?.("href");
      if (originalHref) el.removeAttribute("href");

      if (isSubmitting) return;

      if (!isFormReadyToSubmit()) {
        recomputeSubmitEnabled();
        // restore href if we blocked it
        if (originalHref) el.setAttribute("href", originalHref);
        alert("Пожалуйста, заполните все поля формы правильно.");
        return;
      }

      isSubmitting = true;

      // Показываем индикатор загрузки
      const originalText = btn.textContent;
      btn.style.opacity = "0.7";
      btn.style.cursor = "wait";

      try {
        const success = await sendLeadToBackend();
        
        if (success) {
          console.log("Redirecting to /bot-done");
          window.location.href = "/bot-done";
        } else {
          alert("Не удалось отправить заявку. Пожалуйста, попробуйте еще раз.");
        }
      } catch (error) {
        console.error("Submission error:", error);
        alert("Произошла ошибка при отправке. Пожалуйста, попробуйте еще раз.");
      } finally {
        // Восстанавливаем кнопку
        isSubmitting = false;
        btn.style.opacity = "";
        btn.style.cursor = "";
        if (originalHref) el.setAttribute("href", originalHref);
        recomputeSubmitEnabled();
      }
    }

    // Attach event listeners
    // Use capture=true so our handler runs even if Webflow stops propagation.
    btn.addEventListener("click", handleSubmit, true);
    if (form) form.addEventListener("submit", handleSubmit);
    
    // Экспортируем API для отладки
    window.SheriffExchangeAuth = {
      ensureValidTokens,
      refreshAccessToken,
      performTelegramAuth,
      getStoredTokens,
      clearStoredTokens,
      areTokensExpired,
      apiFetch,
    };
    
    console.log("Exchange form initialized");
  });
})();
</script>