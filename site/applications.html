<!-- Applications page ("Мои заявки") -->
<style>
  /* Telegram WebView scroll fix - IMPORTANT FIX */
  html, body {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    position: relative;
  }

  /* Main content container */
  body > div:first-child,
  .w-webflow-badge ~ div,
  .page-wrapper {
    min-height: 100%;
    height: auto;
    position: relative;
    z-index: 1;
  }

  /* Fix for Webflow's main container */
  [class*="container"]:not([class*="navbar"]):not([class*="footer"]) {
    min-height: 100vh;
    height: auto;
    overflow: visible !important;
  }

  /* Cards container - ensure no overflow hidden */
  #application-block,
  [data-generated="application"] {
    display: block;
    margin-bottom: 16px;
    position: relative;
    z-index: 2;
  }

  /* Remove any overflow:hidden from parent containers */
  section,
  [class*="section"],
  [class*="content"],
  [class*="wrapper"],
  .w-container,
  div[role="main"] {
    overflow: visible !important;
    min-height: auto !important;
    height: auto !important;
    max-height: none !important;
  }

  /* Ensure all content is visible */
  * {
    max-height: none !important;
  }

  /* Add bottom padding for scroll space */
  body::after {
    content: "";
    display: block;
    height: 40px;
    width: 100%;
  }

  /* Telegram specific fixes */
  .telegram-webview {
    overflow-y: auto !important;
  }

  /* Style for generated application blocks */
  [data-generated="application"] {
    display: block !important;
    margin: 0 auto 16px auto !important;
    padding: 16px !important;
    width: calc(100% - 32px) !important;
    max-width: 600px !important;
    background: rgba(255, 255, 255, 0.1) !important;
    border: 2px solid #fcedc2 !important;
    border-radius: 8px !important;
    white-space: pre-line !important;
    color: #fff !important;
    font-family: inherit !important;
    font-size: inherit !important;
    line-height: inherit !important;
    box-sizing: border-box !important;
  }

  /* Ensure sections and containers allow full width */
  section[class*="container"],
  [class*="section"] [class*="container"],
  .w-container,
  div[role="main"] > div {
    width: 100% !important;
    max-width: 100% !important;
    padding-left: 16px !important;
    padding-right: 16px !important;
    box-sizing: border-box !important;
  }
</style>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
(function () {
  const BACKEND_BASE = "https://sheriff-tg-mini-app-backend-dev.up.railway.app";
  const AUTH_REFRESH_ENDPOINT = "/auth/refresh";
  const APPS_ENDPOINT = "/me/applications";
  const TOKEN_STORAGE_KEY = "__sheriff_tokens_v1";

  const BLOCK_ID = "application-block";

  function getBlockEl() {
    return document.getElementById(BLOCK_ID);
  }

  function normalize(s) {
    return String(s ?? "").trim();
  }

  function getStoredTokens() {
    try {
      return JSON.parse(localStorage.getItem(TOKEN_STORAGE_KEY) || "null");
    } catch {
      return null;
    }
  }

  function setStoredTokens(tokens) {
    if (!tokens) {
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      return;
    }
    localStorage.setItem(
      TOKEN_STORAGE_KEY,
      JSON.stringify({
        ...tokens,
        saved_at: Date.now(),
      })
    );
  }

  async function refreshAccessToken() {
    const r = await fetch(BACKEND_BASE + AUTH_REFRESH_ENDPOINT, {
      method: "POST",
      credentials: "include",
    });

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    if (!r.ok) throw new Error(typeof data === "string" ? data : JSON.stringify(data));

    if (data?.access_token && data?.refresh_token) {
      setStoredTokens({
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "bearer",
        expires_in: data.expires_in || null,
      });
    }

    return data;
  }

  // Try to get new tokens if refresh fails
  async function reAuthenticate() {
    const initData = window.Telegram?.WebApp?.initData || "";
    if (!initData) throw new Error("No Telegram initData for re-auth");

    // Must match backend router: POST /auth/telegram-webapp { initData, meta }
    const r = await fetch(BACKEND_BASE + "/auth/telegram-webapp", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        initData,
        meta: {
          platform: window.Telegram?.WebApp?.platform || null,
          version: window.Telegram?.WebApp?.version || null,
          page_url: location.href,
          user_agent: navigator.userAgent,
        },
      }),
      credentials: "include",
    });

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    if (!r.ok) throw new Error(`Re-auth failed HTTP ${r.status}: ${JSON.stringify(data)}`);

    if (data?.access_token && data?.refresh_token) {
      setStoredTokens({
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "bearer",
        expires_in: data.expires_in || null,
      });
    }

    return data;
  }

  async function apiFetch(path, options = {}) {
    // Debug: log outgoing request
    console.log("apiFetch:", { path, method: options.method || "GET" });

    let tokens = getStoredTokens();
    let headers = new Headers(options.headers || {});
    if (tokens?.access_token) headers.set("Authorization", `Bearer ${tokens.access_token}`);

    let r = await fetch(BACKEND_BASE + path, {
      ...options,
      headers,
      credentials: "include",
    });
    if (r.status !== 401) return r;

    // Try refresh
    try {
      await refreshAccessToken();
      tokens = getStoredTokens();
      headers = new Headers(options.headers || {});
      if (tokens?.access_token) headers.set("Authorization", `Bearer ${tokens.access_token}`);
      r = await fetch(BACKEND_BASE + path, {
        ...options,
        headers,
        credentials: "include",
      });
      if (r.status !== 401) return r;
    } catch (e) {
      console.warn("refreshAccessToken failed", e);
    }

    // Try re-authenticate
    try {
      await reAuthenticate();
      tokens = getStoredTokens();
      headers = new Headers(options.headers || {});
      if (tokens?.access_token) headers.set("Authorization", `Bearer ${tokens.access_token}`);
      r = await fetch(BACKEND_BASE + path, {
        ...options,
        headers,
        credentials: "include",
      });
      return r;
    } catch (e) {
      console.warn("reAuthenticate failed", e);
      return r;
    }
  }

  function render(items) {
    const templateBlock = getBlockEl();
    if (!templateBlock) return;

    // Находим контейнер секции - родителя application-block
    const sectionContainer = templateBlock.parentElement;
    if (!sectionContainer) return;

    // Удаляем ВСЕ ранее созданные блоки
    sectionContainer.querySelectorAll('[data-generated="application"]').forEach((n) => n.remove());

    // Скрываем оригинальный блок-шаблон (он нам нужен только как образец)
    templateBlock.style.display = "none";

    const formatDateTime = (isoString) => {
        if (!isoString) return "—";
        try {
            const date = new Date(isoString);
            if (isNaN(date.getTime())) return isoString;
            
            const day = String(date.getDate()).padStart(2, "0");
            const month = String(date.getMonth() + 1).padStart(2, "0");
            const year = date.getFullYear();
            const hours = String(date.getHours()).padStart(2, "0");
            const minutes = String(date.getMinutes()).padStart(2, "0");
            
            return `${day}.${month}.${year} ${hours}:${minutes}`;
        } catch {
            return isoString;
        }
    };

    const formatApp = (app) =>
        [
            `№: ${normalize(app.id)}`,
            `Дата: ${formatDateTime(app.created_at)}`,
            `Город: ${normalize(app.city)}`,
            "",
            `Тип сделки: ${normalize(app.exchange_type)}`,
            `Сумма: ${normalize(app.sum)}`,
            `Тип получения: ${normalize(app.receive_type)}`,
        ].join("\n");

    if (!items?.length) {
        // Если нет заявок, показываем сообщение в отдельном блоке
        const noAppsBlock = document.createElement('div');
        noAppsBlock.setAttribute("data-generated", "application");
        noAppsBlock.textContent = "Заявок пока нет";
        noAppsBlock.style.cssText = `
            display: block !important;
            margin: 0 auto 16px auto !important;
            padding: 16px !important;
            width: calc(100% - 32px) !important;
            max-width: 600px !important;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 2px solid #fcedc2 !important;
            border-radius: 8px !important;
            white-space: pre-line !important;
            color: #fff !important;
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
            box-sizing: border-box !important;
        `;
        sectionContainer.insertBefore(noAppsBlock, templateBlock);
        return;
    }

    // Создаем блоки для ВСЕХ заявок
    items.forEach((item, index) => {
        const newBlock = document.createElement('div');
        newBlock.setAttribute("data-generated", "application");
        
        // Применяем обновленные стили с желтой рамкой и почти полной шириной
        newBlock.style.cssText = `
            display: block !important;
            margin: 0 auto 16px auto !important;
            padding: 16px !important;
            width: calc(100% - 32px) !important;
            max-width: 600px !important;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 2px solid #fcedc2 !important;
            border-radius: 8px !important;
            white-space: pre-line !important;
            color: #fff !important;
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
            box-sizing: border-box !important;
        `;
        
        // Устанавливаем текст заявки
        newBlock.textContent = formatApp(item);
        
        // Вставляем блок в контейнер, ПЕРЕД оригинальным блоком-шаблоном
        sectionContainer.insertBefore(newBlock, templateBlock);
    });
  }

  async function loadApplications(retryOnAuth = true) {
    const block = getBlockEl();
    if (block) {
        // Показываем загрузку в оригинальном блоке
        const textEl = block.querySelector("#application-text") || block;
        textEl.textContent = "Загрузка...";
        textEl.style.whiteSpace = "pre-line";
        textEl.style.color = "#fff";
        block.style.display = "block";
    }

    const r = await apiFetch(APPS_ENDPOINT, { method: "GET" });

    if (r.status === 401 && retryOnAuth) {
      // Try to re-authenticate and retry ONCE
      try {
        await reAuthenticate();
        return await loadApplications(false);
      } catch (e) {
        // fall through to error
      }
    }

    if (!r.ok) {
        const text = await r.text().catch(() => "");
        throw new Error(`HTTP ${r.status}: ${text}`);
    }

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    // Сортируем заявки по дате создания в обратном порядке (новые сверху)
    let items = data.items || [];
    items.sort((a, b) => {
        const dateA = new Date(a.created_at || 0).getTime();
        const dateB = new Date(b.created_at || 0).getTime();
        return dateB - dateA; // Обратный порядок
    });
    render(items);
  }

  document.addEventListener("DOMContentLoaded", async () => {
    // Telegram WebApp initialization
    if (window.Telegram?.WebApp) {
      window.Telegram.WebApp.ready();
      window.Telegram.WebApp.expand();
      
      // IMPORTANT: This is crucial for scrolling to work
      window.Telegram.WebApp.setHeaderColor('#000000');
      window.Telegram.WebApp.setBackgroundColor('#000000');
      
      // Enable smooth scrolling
      window.Telegram.WebApp.enableClosingConfirmation?.();
      
      // Fix for iOS scrolling
      if (navigator.userAgent.match(/iPhone|iPad|iPod/)) {
        document.documentElement.style.height = '100%';
        document.body.style.height = '100%';
        document.body.style.overflowY = 'scroll';
        document.body.style.webkitOverflowScrolling = 'touch';
        
        // Force layout update
        setTimeout(() => {
          document.body.style.height = (document.body.scrollHeight + 1) + 'px';
        }, 100);
      }
    }

    // Remove any touch event blocking
    document.body.addEventListener('touchmove', function(e) {
      // Allow all touch events to propagate for scrolling
    }, { passive: true });

    // Add scroll event listener to ensure scrolling works
    document.addEventListener('scroll', function() {
      // This helps trigger scrolling on iOS
    }, { passive: true });

    // Fix Webflow's body height
    setTimeout(() => {
      document.body.style.minHeight = '100vh';
      document.body.style.height = 'auto';
      
      // Remove any overflow:hidden from body
      document.body.style.overflow = '';
      document.body.style.overflowX = '';
      document.body.style.overflowY = '';
      
      // Also fix html element
      document.documentElement.style.overflow = '';
      document.documentElement.style.overflowX = '';
      document.documentElement.style.overflowY = '';
      
      // Ensure containers allow full width
      const containers = document.querySelectorAll('section[class*="container"], [class*="section"] [class*="container"], .w-container');
      containers.forEach(container => {
        container.style.width = '100%';
        container.style.maxWidth = '100%';
        container.style.paddingLeft = '16px';
        container.style.paddingRight = '16px';
        container.style.boxSizing = 'border-box';
      });
    }, 50);

    // Load applications
    try {
      await loadApplications();
      
      // After rendering, ensure scrolling is possible
      setTimeout(() => {
        if (document.body.scrollHeight > window.innerHeight) {
          document.body.style.height = 'auto';
          document.body.style.minHeight = '100%';
        }
      }, 200);
    } catch (e) {
      console.error("Failed to load applications", e);
      const block = getBlockEl();
      if (block) {
          const textEl = block.querySelector("#application-text") || block;
          textEl.textContent = "Не удалось загрузить заявки";
          textEl.style.whiteSpace = "pre-line";
          textEl.style.color = "#fff";
          block.style.display = "block";
      }
    }
  });
})();
</script>