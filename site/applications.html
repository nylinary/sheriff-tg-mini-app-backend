<!-- Applications page ("Мои заявки") -->
<style>
  /* Telegram WebView scroll fix - IMPORTANT FIX */
  html, body {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    position: relative;
  }

  /* Main content container */
  body > div:first-child,
  .w-webflow-badge ~ div,
  .page-wrapper {
    min-height: 100%;
    height: auto;
    position: relative;
    z-index: 1;
  }

  /* Fix for Webflow's main container */
  [class*="container"]:not([class*="navbar"]):not([class*="footer"]) {
    min-height: 100vh;
    height: auto;
    overflow: visible !important;
  }

  /* Cards container - ensure no overflow hidden */
  #application-block,
  [data-generated="application"] {
    display: block;
    margin-bottom: 16px;
    position: relative;
    z-index: 2;
  }

  /* Remove any overflow:hidden from parent containers */
  section,
  [class*="section"],
  [class*="content"],
  [class*="wrapper"],
  .w-container,
  div[role="main"] {
    overflow: visible !important;
    min-height: auto !important;
    height: auto !important;
    max-height: none !important;
  }

  /* Ensure all content is visible */
  * {
    max-height: none !important;
  }

  /* Add bottom padding for scroll space */
  body::after {
    content: "";
    display: block;
    height: 40px;
    width: 100%;
  }

  /* Telegram specific fixes */
  .telegram-webview {
    overflow-y: auto !important;
  }
</style>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
(function () {
  const BACKEND_BASE = "https://sheriff-tg-mini-app-backend-dev.up.railway.app";
  const AUTH_REFRESH_ENDPOINT = "/auth/refresh";
  const APPS_ENDPOINT = "/me/applications";
  const TOKEN_STORAGE_KEY = "__sheriff_tokens_v1";

  const BLOCK_ID = "application-block";

  function getBlockEl() {
    return document.getElementById(BLOCK_ID);
  }

  function normalize(s) {
    return String(s ?? "").trim();
  }

  function getStoredTokens() {
    try {
      return JSON.parse(localStorage.getItem(TOKEN_STORAGE_KEY) || "null");
    } catch {
      return null;
    }
  }

  function setStoredTokens(tokens) {
    if (!tokens) {
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      return;
    }
    localStorage.setItem(
      TOKEN_STORAGE_KEY,
      JSON.stringify({
        ...tokens,
        saved_at: Date.now(),
      })
    );
  }

  async function refreshAccessToken() {
    const r = await fetch(BACKEND_BASE + AUTH_REFRESH_ENDPOINT, {
      method: "POST",
      credentials: "include",
    });

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    if (!r.ok) throw new Error(typeof data === "string" ? data : JSON.stringify(data));

    if (data?.access_token && data?.refresh_token) {
      setStoredTokens({
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "bearer",
        expires_in: data.expires_in || null,
      });
    }

    return data;
  }

  async function apiFetch(path, options = {}) {
    const tokens = getStoredTokens();
    const headers = new Headers(options.headers || {});

    if (tokens?.access_token) headers.set("Authorization", `Bearer ${tokens.access_token}`);

    const first = await fetch(BACKEND_BASE + path, {
      ...options,
      headers,
      credentials: "include",
    });

    if (first.status !== 401) return first;

    await refreshAccessToken();

    const tokens2 = getStoredTokens();
    const headers2 = new Headers(options.headers || {});
    if (tokens2?.access_token) headers2.set("Authorization", `Bearer ${tokens2.access_token}`);

    return fetch(BACKEND_BASE + path, {
      ...options,
      headers: headers2,
      credentials: "include",
    });
  }

  function render(items) {
    const templateBlock = getBlockEl();
    if (!templateBlock) return;

    const parent = templateBlock.parentElement;
    if (!parent) return;

    // Remove previously generated duplicates
    parent.querySelectorAll('[data-generated="application"]').forEach((n) => n.remove());

    const templateTextEl = templateBlock.querySelector("#application-text") || templateBlock;

    const formatDateTime = (isoString) => {
      if (!isoString) return "—";
      try {
        const date = new Date(isoString);
        if (isNaN(date.getTime())) return isoString;
        
        const day = String(date.getDate()).padStart(2, "0");
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, "0");
        const minutes = String(date.getMinutes()).padStart(2, "0");
        
        return `${day}.${month}.${year} ${hours}:${minutes}`;
      } catch {
        return isoString;
      }
    };

    const formatApp = (app) =>
      [
        `№: ${normalize(app.id)}`,
        `Дата: ${formatDateTime(app.created_at)}`,
        `Город: ${normalize(app.city)}`,
        "",
        `Тип сделки: ${normalize(app.exchange_type)}`,
        `Сумма: ${normalize(app.sum)}`,
        `Тип получения: ${normalize(app.receive_type)}`,
      ].join("\n");

    const applyTextStyle = (el) => {
      if (!(el instanceof HTMLElement)) return;
      el.style.whiteSpace = "pre-line";
      el.style.color = "#fff";
    };

    const fillBlock = (blockEl, textValue) => {
      const textEl = blockEl.querySelector("#application-text") || blockEl;
      if (!(textEl instanceof HTMLElement)) return;
      textEl.textContent = textValue;
      applyTextStyle(textEl);
    };

    if (!items?.length) {
      fillBlock(templateBlock, "Заявок пока нет");
      return;
    }

    // Fill existing block with the first application
    fillBlock(templateBlock, formatApp(items[0]));

    // Clone for the rest
    for (let i = 1; i < items.length; i++) {
      const clone = templateBlock.cloneNode(true);
      if (!(clone instanceof HTMLElement)) continue;

      clone.setAttribute("data-generated", "application");

      // Important: ensure unique ids in clones (Webflow template uses id=application-block)
      clone.removeAttribute("id");
      const inner = clone.querySelector("#application-text");
      if (inner instanceof HTMLElement) inner.removeAttribute("id");

      fillBlock(clone, formatApp(items[i]));

      // Insert before the template as requested
      parent.insertBefore(clone, templateBlock);
    }
  }

  async function loadApplications() {
    const block = getBlockEl();
    if (block) {
        block.textContent = "Загрузка...";
        block.style.color = "#fff";
    }

    const r = await apiFetch(APPS_ENDPOINT, { method: "GET" });

    if (!r.ok) {
        const text = await r.text().catch(() => "");
        throw new Error(`HTTP ${r.status}: ${text}`);
    }

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    
    // Сортируем заявки по дате создания в обратном порядке (новые сверху)
    let items = data.items || [];
    items.sort((a, b) => {
        const dateA = new Date(a.created_at || 0).getTime();
        const dateB = new Date(b.created_at || 0).getTime();
        return dateB - dateA; // Обратный порядок
    });
    
    render(items);
  }

  document.addEventListener("DOMContentLoaded", async () => {
    // Telegram WebApp initialization
    if (window.Telegram?.WebApp) {
      window.Telegram.WebApp.ready();
      window.Telegram.WebApp.expand();
      
      // IMPORTANT: This is crucial for scrolling to work
      window.Telegram.WebApp.setHeaderColor('#000000');
      window.Telegram.WebApp.setBackgroundColor('#000000');
      
      // Enable smooth scrolling
      window.Telegram.WebApp.enableClosingConfirmation?.();
      
      // Fix for iOS scrolling
      if (navigator.userAgent.match(/iPhone|iPad|iPod/)) {
        document.documentElement.style.height = '100%';
        document.body.style.height = '100%';
        document.body.style.overflowY = 'scroll';
        document.body.style.webkitOverflowScrolling = 'touch';
        
        // Force layout update
        setTimeout(() => {
          document.body.style.height = (document.body.scrollHeight + 1) + 'px';
        }, 100);
      }
    }

    // Remove any touch event blocking
    document.body.addEventListener('touchmove', function(e) {
      // Allow all touch events to propagate for scrolling
    }, { passive: true });

    // Add scroll event listener to ensure scrolling works
    document.addEventListener('scroll', function() {
      // This helps trigger scrolling on iOS
    }, { passive: true });

    // Fix Webflow's body height
    setTimeout(() => {
      document.body.style.minHeight = '100vh';
      document.body.style.height = 'auto';
      
      // Remove any overflow:hidden from body
      document.body.style.overflow = '';
      document.body.style.overflowX = '';
      document.body.style.overflowY = '';
      
      // Also fix html element
      document.documentElement.style.overflow = '';
      document.documentElement.style.overflowX = '';
      document.documentElement.style.overflowY = '';
    }, 50);

    // Load applications
    try {
      await loadApplications();
      
      // After rendering, ensure scrolling is possible
      setTimeout(() => {
        if (document.body.scrollHeight > window.innerHeight) {
          document.body.style.height = 'auto';
          document.body.style.minHeight = '100%';
        }
      }, 200);
    } catch (e) {
      console.error("Failed to load applications", e);
      const block = getBlockEl();
      if (block) block.textContent = "Не удалось загрузить заявки";
    }
  });
})();
</script>