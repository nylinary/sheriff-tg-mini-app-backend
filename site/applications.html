<!-- Applications page ("Мои заявки") -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
(function () {
  const BACKEND_BASE = "https://sheriff-tg-mini-app-backend-dev.up.railway.app";
  const AUTH_REFRESH_ENDPOINT = "/auth/refresh";
  const APPS_ENDPOINT = "/me/applications";
  const TOKEN_STORAGE_KEY = "__sheriff_tokens_v1";

  const BLOCK_ID = "application-block";

  function getBlockEl() {
    return document.getElementById(BLOCK_ID);
  }

  function normalize(s) {
    return String(s ?? "").trim();
  }

  function getStoredTokens() {
    try {
      return JSON.parse(localStorage.getItem(TOKEN_STORAGE_KEY) || "null");
    } catch {
      return null;
    }
  }

  function setStoredTokens(tokens) {
    if (!tokens) {
      localStorage.removeItem(TOKEN_STORAGE_KEY);
      return;
    }
    localStorage.setItem(
      TOKEN_STORAGE_KEY,
      JSON.stringify({
        ...tokens,
        saved_at: Date.now(),
      })
    );
  }

  async function refreshAccessToken() {
    const r = await fetch(BACKEND_BASE + AUTH_REFRESH_ENDPOINT, {
      method: "POST",
      credentials: "include",
    });

    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    if (!r.ok) throw new Error(typeof data === "string" ? data : JSON.stringify(data));

    if (data?.access_token && data?.refresh_token) {
      setStoredTokens({
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "bearer",
        expires_in: data.expires_in || null,
      });
    }

    return data;
  }

  async function apiFetch(path, options = {}) {
    const tokens = getStoredTokens();
    const headers = new Headers(options.headers || {});

    if (tokens?.access_token) headers.set("Authorization", `Bearer ${tokens.access_token}`);

    const first = await fetch(BACKEND_BASE + path, {
      ...options,
      headers,
      credentials: "include",
    });

    if (first.status !== 401) return first;

    await refreshAccessToken();

    const tokens2 = getStoredTokens();
    const headers2 = new Headers(options.headers || {});
    if (tokens2?.access_token) headers2.set("Authorization", `Bearer ${tokens2.access_token}`);

    return fetch(BACKEND_BASE + path, {
      ...options,
      headers: headers2,
      credentials: "include",
    });
  }

  function render(items) {
    const templateBlock = getBlockEl();
    if (!templateBlock) return;

    const templateText = templateBlock.querySelector("#application-text");
    if (!(templateText instanceof HTMLElement)) {
      // Fallback to old behavior if template is not present
      templateBlock.textContent = "Missing #application-text inside #application-block";
      return;
    }

    const parent = templateBlock.parentElement;
    if (!parent) return;

    // Remove previously generated duplicates (we mark them)
    parent.querySelectorAll('[data-generated="application"]').forEach((n) => n.remove());

    // Helper to format one application
    const formatApp = (app) =>
      [
        `№: ${normalize(app.id)}`,
        `Дата: ${normalize(app.created_at)}`,
        `Город: ${normalize(app.city)}`,
        "",
        `Тип сделки: ${normalize(app.exchange_type)}`,
        `Сумма: ${normalize(app.sum)}`,
        `Тип получения: ${normalize(app.receive_type)}`,
      ].join("\n");

    // Ensure white text + newlines
    const applyTextStyle = (textEl) => {
      if (!(textEl instanceof HTMLElement)) return;
      textEl.style.whiteSpace = "pre-line";
      textEl.style.color = "#fff";
    };

    const fillBlock = (blockEl, textValue) => {
      const textEl = blockEl.querySelector("#application-text");
      if (textEl) {
        textEl.textContent = textValue;
        applyTextStyle(textEl);
      }
    };

    if (!items?.length) {
      fillBlock(templateBlock, "Заявок пока нет");
      return;
    }

    // 1) Fill existing block with the first application
    fillBlock(templateBlock, formatApp(items[0]));

    // 2) For the rest: clone the template block and insert as preceding siblings
    for (let i = 1; i < items.length; i++) {
      const clone = templateBlock.cloneNode(true);
      if (!(clone instanceof HTMLElement)) continue;

      // Mark so we can remove on re-render
      clone.setAttribute("data-generated", "application");

      // IDs must be unique: remove ids in clones
      clone.removeAttribute("id");
      const cloneText = clone.querySelector("#application-text");
      if (cloneText instanceof HTMLElement) cloneText.removeAttribute("id");

      fillBlock(clone, formatApp(items[i]));

      parent.insertBefore(clone, templateBlock);
    }
  }

  async function loadApplications() {
    const block = getBlockEl();
    if (block) block.textContent = "Загрузка...";

    const r = await apiFetch(APPS_ENDPOINT, { method: "GET" });
    const data = await r.json().catch(async () => ({ raw: await r.text() }));
    if (!r.ok) throw new Error(typeof data === "string" ? data : JSON.stringify(data));

    render(data.items || []);
  }

  document.addEventListener("DOMContentLoaded", async () => {
    window.Telegram?.WebApp?.ready?.();

    try {
      await loadApplications();
    } catch (e) {
      console.error("Failed to load applications", e);
      const block = getBlockEl();
      if (block) block.textContent = "Не удалось загрузить заявки";
    }
  });
})();
</script>
